{"pages":[],"posts":[{"title":"ArrayList","text":"ArrayList和CopyOnWriteArrayList的增删改查实现原理 List接口方法视图： 1234567891011121314151617181920212223242526272829public interface List&lt;E&gt; extends Collection&lt;E&gt; { int size(); boolean isEmpty(); boolean contains(Object o); Iterator&lt;E&gt; iterator(); Object[] toArray(); &lt;T&gt; T[] toArray(T[] a); boolean add(E e); boolean remove(Object o); boolean containsAll(Collection&lt;?&gt; c); boolean addAll(Collection&lt;? extends E&gt; c); boolean addAll(int index, Collection&lt;? extends E&gt; c); boolean removeAll(Collection&lt;?&gt; c); boolean retainAll(Collection&lt;?&gt; c); void clear(); boolean equals(Object o); int hashCode(); E get(int index); E set(int index, E element); void add(int index, E element); E remove(int index); int indexOf(Object o); int lastIndexOf(Object o); ListIterator&lt;E&gt; listIterator(); ListIterator&lt;E&gt; listIterator(int index); List&lt;E&gt; subList(int fromIndex, int toIndex);} ArrayList的实现机制：arraylist 底层实现为数组， 默认初始大小为10 遇到需要扩容的状况，会采用 Arrays.copyOf 的方法进行数组的复制 具体的扩容策略为： 12345678910111213141516171819private Object[] grow(int minCapacity) { int oldCapacity = elementData.length; if (oldCapacity &gt; 0 || elementData != DEFAULTCAPACITY_EMPTY_ELEMENTDATA) { // 扩容 最小值（minCapacity - oldCapacity实际为当前容量加1） // 扩容 理想值（oldCapacity&gt;&gt;1） //优先按照 理想值 进行扩容 //如果失败则对 最小值 扩容 //如果还无法满足则 throw 异常 int newCapacity = ArraysSupport.newLength(oldCapacity, minCapacity - oldCapacity, /* minimum growth */ oldCapacity &gt;&gt; 1 /* preferred growth */); return elementData = Arrays.copyOf(elementData, newCapacity); } else { return elementData = new Object[Math.max(DEFAULT_CAPACITY, minCapacity)]; }} ArrayList增删改查的方法：增加元素方法： ​ 在ArrayList 内部 add()方法的重载都是基于本方法，在进行 增加元素之前只检查了数组容量 ​ 1234567 private void add(E e, Object[] elementData, int s) { if (s == elementData.length) elementData = grow(); elementData[s] = e; size = s + 1; } 对于指定 位置 进行增加的 add(int index, E element) 方法： 1234567891011121314public void add(int index, E element) { rangeCheckForAdd(index); modCount++; final int s; Object[] elementData; if ((s = size) == (elementData = this.elementData).length) //扩容 完成之后 再整体将 index 位置之后的所有元素 拷贝到index后一个位置 elementData = grow(); System.arraycopy(elementData, index, elementData, index + 1, s - index); elementData[index] = element; size = s + 1;} 2) 删除 删除有按照索引 remove(int index)删除 和 按照元素 remove(Object o) 删除两种 下面为 remove(int index)中的核心方法 ： ​ 可以看见 对于指定位置的删除依然是采取 arraycopy()的思路 1234567private void fastRemove(Object[] es, int i) { modCount++; final int newSize; if ((newSize = size - 1) &gt; i) System.arraycopy(es, i + 1, es, i, newSize - i); es[size = newSize] = null;} 下面为 remove(Object o) 的方法： ​ 可以看到即使是根据元素删除也是找到对应元素所在的下标 然后执行 快速删除 fastRemove 1234567891011121314151617181920public boolean remove(Object o) { final Object[] es = elementData; final int size = this.size; int i = 0; //label 语法 found: { if (o == null) { for (; i &lt; size; i++) if (es[i] == null) break found; } else { for (; i &lt; size; i++) if (o.equals(es[i])) break found; } return false; } fastRemove(es, i); return true;} 3) 修改 ​ 只需要判断 给定的index 是否合法即可 123456public E set(int index, E element) { Objects.checkIndex(index, size); E oldValue = elementData(index); elementData[index] = element; return oldValue;} 4) 查询 ​ 比较简单就不说了 1234public E get(int index) { Objects.checkIndex(index, size); return elementData(index);} 总结:​ ArrayList的底层是数组，所以查询的时候直接根据索引可以很快找到对应的元素，改也是如此，找到index对应元素进行替换。而增加和删除就涉及到数组元素的移动，所以会比较慢。 CopyOnWriteArrayListCopyOnWrite是一种linux 底层技术，简而言之，在不同进程访问同一资源时，只有在写操作时，才会去复制新的数据。否则访问的丢失同一个资源。 在查询数据的情况下，是没有限制的，而在修改的时候会基于原始数据做一份拷贝副本，随后在拷贝的副本上进行修改，在拷贝 &gt;&gt; 修改的整个过程中会通过锁来控制线程互斥，此时对于读线程而言并不会阻塞，最后会将拷贝副本重新替换到原始数据上，显然，这种特性实现的是 最终一致性 。 CopyOnWriteArrayList实现机制​ 底层任然采用数组实现，相比于 ArrayList 的底层数组实现 ，CopyOnWriteArrayList 只使用了一个默认数组 1private transient volatile Object[] array; 构造器也相当简单，提供了如下三种构造方式：123public CopyOnWriteArrayList() public CopyOnWriteArrayList(Collection&lt;? extends E&gt; c) public CopyOnWriteArrayList(E[] toCopyIn) ​ CopyOnWriteArrayList增删改查的方法：1) 增 123456789101112131415161718192021222324252627282930313233343536373839 //比较简单没什么说的public boolean add(E e) { synchronized (lock) { Object[] es = getArray(); int len = es.length; es = Arrays.copyOf(es, len + 1); es[len] = e; setArray(es); return true; } } public void add(int index, E element) { synchronized (lock) { Object[] es = getArray(); int len = es.length; if (index &gt; len || index &lt; 0) throw new IndexOutOfBoundsException(outOfBounds(index, len)); Object[] newElements; //index 之后的位置 int numMoved = len - index; if (numMoved == 0) //无多余位置（index为最后一个）需要在拷贝时进行 +1 扩容 newElements = Arrays.copyOf(es, len + 1); else { //数组有多余位置（index在中间位置） newElements = new Object[len + 1]; //分两次进行拷贝 System.arraycopy(es, 0, newElements, 0, index); System.arraycopy(es, index, newElements, index + 1, numMoved); } //最后将element 放入index位置 newElements[index] = element; //将拷贝之后的数组再回写到原始数据 setArray(newElements); } } 2)删除 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172 public E remove(int index) { synchronized (lock) { Object[] es = getArray(); int len = es.length; //通过内置方法获取元素值 E oldValue = elementAt(es, index); //找寻index之后元素需要移动的个数 int numMoved = len - index - 1; Object[] newElements; if (numMoved == 0) newElements = Arrays.copyOf(es, len - 1); else { //申请新的数组 newElements = new Object[len - 1]; //从index 分前后两次拷贝 System.arraycopy(es, 0, newElements, 0, index); System.arraycopy(es, index + 1, newElements, index, numMoved); } //回写到原始数据 setArray(newElements); return oldValue; } }//根据一个对象 删除元素 public boolean remove(Object o) { Object[] snapshot = getArray(); //查询第一次出现的 元素 o 的位置index int index = indexOfRange(o, snapshot, 0, snapshot.length); return index &gt;= 0 &amp;&amp; remove(o, snapshot, index); }//从一段数组快照中通过index删除指定元素 private boolean remove(Object o, Object[] snapshot, int index) { synchronized (lock) { Object[] current = getArray(); int len = current.length; //snapshot是在上锁之前读取的; 而current是最新的,已经被上锁保护不会被修改的 //如果二者不相等(任何修改操作都会产生回写)， 则证明需要重新定位待删除元素的位置 //这时候会由三种情况 //1 index 是尾部且已经被删除 //2 index在中间但位置已经改变 //3 index位置未被改变 if (snapshot != current) findIndex: { int prefix = Math.min(index, len); for (int i = 0; i &lt; prefix; i++) { if (current[i] != snapshot[i] &amp;&amp; Objects.equals(o, current[i])) { index = i; break findIndex; } } if (index &gt;= len) return false; if (current[index] == o) break findIndex; index = indexOfRange(o, current, index, len); if (index &lt; 0) return false; } //找到位置之后 ，采用复制的方式对 index 前后元素进行操作 Object[] newElements = new Object[len - 1]; System.arraycopy(current, 0, newElements, 0, index); System.arraycopy(current, index + 1, newElements, index, len - index - 1); setArray(newElements); return true; } } 3) 修改 ​ 可以见到这里进行了 加锁 以及 拷贝&amp;回写 的操作 1234567891011121314public E set(int index, E element) { synchronized (lock) { Object[] es = getArray(); E oldValue = elementAt(es, index); if (oldValue != element) { es = es.clone(); es[index] = element; } // Ensure volatile write semantics even when oldvalue == element setArray(es); return oldValue; }} 4) 查找 ​ 查找非常简单 没有涉及到锁 1234567public E get(int index) { return elementAt(getArray(), index);}@SuppressWarnings(\"unchecked\")static &lt;E&gt; E elementAt(Object[] a, int index) { return (E) a[index];} 总结:​ 从以上的增删改查中我们可以发现，增删改都需要获得锁，并且锁只有一把，而读操作不需要获得锁，支持并发。为什么增删改中都需要创建一个新的数组，操作完成之后再赋给原来的引用？这是为了保证get的时候都能获取到元素，如果在增删改过程直接修改原来的数组，可能会造成执行读操作获取不到数据。","link":"/myblob/2020/01/30/ArrayList/"}],"tags":[],"categories":[]}