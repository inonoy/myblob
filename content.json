{"pages":[],"posts":[{"title":"ArrayList","text":"ArrayList和CopyOnWriteArrayList的增删改查实现原理 List接口方法视图： 1234567891011121314151617181920212223242526272829public interface List&lt;E&gt; extends Collection&lt;E&gt; { int size(); boolean isEmpty(); boolean contains(Object o); Iterator&lt;E&gt; iterator(); Object[] toArray(); &lt;T&gt; T[] toArray(T[] a); boolean add(E e); boolean remove(Object o); boolean containsAll(Collection&lt;?&gt; c); boolean addAll(Collection&lt;? extends E&gt; c); boolean addAll(int index, Collection&lt;? extends E&gt; c); boolean removeAll(Collection&lt;?&gt; c); boolean retainAll(Collection&lt;?&gt; c); void clear(); boolean equals(Object o); int hashCode(); E get(int index); E set(int index, E element); void add(int index, E element); E remove(int index); int indexOf(Object o); int lastIndexOf(Object o); ListIterator&lt;E&gt; listIterator(); ListIterator&lt;E&gt; listIterator(int index); List&lt;E&gt; subList(int fromIndex, int toIndex);} ArrayList的实现机制：Arraylist 底层实现为数组， 默认初始大小为10 遇到需要扩容的状况，会采用 Arrays.copyOf 的方法进行数组的复制 具体的扩容策略为： 12345678910111213141516171819private Object[] grow(int minCapacity) { int oldCapacity = elementData.length; if (oldCapacity &gt; 0 || elementData != DEFAULTCAPACITY_EMPTY_ELEMENTDATA) { // 扩容 最小值（minCapacity - oldCapacity实际为当前容量加1） // 扩容 理想值（oldCapacity&gt;&gt;1） //优先按照 理想值 进行扩容 //如果失败则对 最小值 扩容 //如果还无法满足则 throw 异常 int newCapacity = ArraysSupport.newLength(oldCapacity, minCapacity - oldCapacity, /* minimum growth */ oldCapacity &gt;&gt; 1 /* preferred growth */); return elementData = Arrays.copyOf(elementData, newCapacity); } else { return elementData = new Object[Math.max(DEFAULT_CAPACITY, minCapacity)]; }} ArrayList增删改查的方法：增加元素方法： ​ 在ArrayList 内部 add()方法的重载都是基于本方法，在进行 增加元素之前只检查了数组容量 ​ 1234567 private void add(E e, Object[] elementData, int s) { if (s == elementData.length) elementData = grow(); elementData[s] = e; size = s + 1; } 对于指定 位置 进行增加的 add(int index, E element) 方法： 1234567891011121314public void add(int index, E element) { rangeCheckForAdd(index); modCount++; final int s; Object[] elementData; if ((s = size) == (elementData = this.elementData).length) //扩容 完成之后 再整体将 index 位置之后的所有元素 拷贝到index后一个位置 elementData = grow(); System.arraycopy(elementData, index, elementData, index + 1, s - index); elementData[index] = element; size = s + 1;} 2) 删除 删除有按照索引 remove(int index)删除 和 按照元素 remove(Object o) 删除两种 下面为 remove(int index)中的核心方法 ： ​ 可以看见 对于指定位置的删除依然是采取 arraycopy()的思路 1234567private void fastRemove(Object[] es, int i) { modCount++; final int newSize; if ((newSize = size - 1) &gt; i) System.arraycopy(es, i + 1, es, i, newSize - i); es[size = newSize] = null;} 下面为 remove(Object o) 的方法： ​ 可以看到即使是根据元素删除也是找到对应元素所在的下标 然后执行 快速删除 fastRemove 1234567891011121314151617181920public boolean remove(Object o) { final Object[] es = elementData; final int size = this.size; int i = 0; //label 语法 found: { if (o == null) { for (; i &lt; size; i++) if (es[i] == null) break found; } else { for (; i &lt; size; i++) if (o.equals(es[i])) break found; } return false; } fastRemove(es, i); return true;} 3) 修改 ​ 只需要判断 给定的index 是否合法即可 123456public E set(int index, E element) { Objects.checkIndex(index, size); E oldValue = elementData(index); elementData[index] = element; return oldValue;} 4) 查询 ​ 比较简单就不说了 1234public E get(int index) { Objects.checkIndex(index, size); return elementData(index);} 总结:​ ArrayList的底层是数组，所以查询的时候直接根据索引可以很快找到对应的元素，改也是如此，找到index对应元素进行替换。而增加和删除就涉及到数组元素的移动，所以会比较慢。 CopyOnWriteArrayListCopyOnWrite是一种linux 底层技术，简而言之，在不同进程访问同一资源时，只有在写操作时，才会去复制新的数据。否则访问的丢失同一个资源。 在查询数据的情况下，是没有限制的，而在修改的时候会基于原始数据做一份拷贝副本，随后在拷贝的副本上进行修改，在拷贝 &gt;&gt; 修改的整个过程中会通过锁来控制线程互斥，此时对于读线程而言并不会阻塞，最后会将拷贝副本重新替换到原始数据上，显然，这种特性实现的是 最终一致性 。 CopyOnWriteArrayList实现机制​ 底层任然采用数组实现，相比于 ArrayList 的底层数组实现 ，CopyOnWriteArrayList 只使用了一个默认数组 1private transient volatile Object[] array; 构造器也相当简单，提供了如下三种构造方式：123public CopyOnWriteArrayList() public CopyOnWriteArrayList(Collection&lt;? extends E&gt; c) public CopyOnWriteArrayList(E[] toCopyIn) ​ CopyOnWriteArrayList增删改查的方法：1) 增 123456789101112131415161718192021222324252627282930313233343536373839 //比较简单没什么说的public boolean add(E e) { synchronized (lock) { Object[] es = getArray(); int len = es.length; es = Arrays.copyOf(es, len + 1); es[len] = e; setArray(es); return true; } } public void add(int index, E element) { synchronized (lock) { Object[] es = getArray(); int len = es.length; if (index &gt; len || index &lt; 0) throw new IndexOutOfBoundsException(outOfBounds(index, len)); Object[] newElements; //index 之后的位置 int numMoved = len - index; if (numMoved == 0) //无多余位置（index为最后一个）需要在拷贝时进行 +1 扩容 newElements = Arrays.copyOf(es, len + 1); else { //数组有多余位置（index在中间位置） newElements = new Object[len + 1]; //分两次进行拷贝 System.arraycopy(es, 0, newElements, 0, index); System.arraycopy(es, index, newElements, index + 1, numMoved); } //最后将element 放入index位置 newElements[index] = element; //将拷贝之后的数组再回写到原始数据 setArray(newElements); } } 2)删除 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172 public E remove(int index) { synchronized (lock) { Object[] es = getArray(); int len = es.length; //通过内置方法获取元素值 E oldValue = elementAt(es, index); //找寻index之后元素需要移动的个数 int numMoved = len - index - 1; Object[] newElements; if (numMoved == 0) newElements = Arrays.copyOf(es, len - 1); else { //申请新的数组 newElements = new Object[len - 1]; //从index 分前后两次拷贝 System.arraycopy(es, 0, newElements, 0, index); System.arraycopy(es, index + 1, newElements, index, numMoved); } //回写到原始数据 setArray(newElements); return oldValue; } }//根据一个对象 删除元素 public boolean remove(Object o) { Object[] snapshot = getArray(); //查询第一次出现的 元素 o 的位置index int index = indexOfRange(o, snapshot, 0, snapshot.length); return index &gt;= 0 &amp;&amp; remove(o, snapshot, index); }//从一段数组快照中通过index删除指定元素 private boolean remove(Object o, Object[] snapshot, int index) { synchronized (lock) { Object[] current = getArray(); int len = current.length; //snapshot是在上锁之前读取的; 而current是最新的,已经被上锁保护不会被修改的 //如果二者不相等(任何修改操作都会产生回写)， 则证明需要重新定位待删除元素的位置 //这时候会由三种情况 //1 index 是尾部且已经被删除 //2 index在中间但位置已经改变 //3 index位置未被改变 if (snapshot != current) findIndex: { int prefix = Math.min(index, len); for (int i = 0; i &lt; prefix; i++) { if (current[i] != snapshot[i] &amp;&amp; Objects.equals(o, current[i])) { index = i; break findIndex; } } if (index &gt;= len) return false; if (current[index] == o) break findIndex; index = indexOfRange(o, current, index, len); if (index &lt; 0) return false; } //找到位置之后 ，采用复制的方式对 index 前后元素进行操作 Object[] newElements = new Object[len - 1]; System.arraycopy(current, 0, newElements, 0, index); System.arraycopy(current, index + 1, newElements, index, len - index - 1); setArray(newElements); return true; } } 3) 修改 ​ 可以见到这里进行了 加锁 以及 拷贝&amp;回写 的操作 1234567891011121314public E set(int index, E element) { synchronized (lock) { Object[] es = getArray(); E oldValue = elementAt(es, index); if (oldValue != element) { es = es.clone(); es[index] = element; } // Ensure volatile write semantics even when oldvalue == element setArray(es); return oldValue; }} 4) 查找 ​ 查找非常简单 没有涉及到锁 1234567public E get(int index) { return elementAt(getArray(), index);}@SuppressWarnings(\"unchecked\")static &lt;E&gt; E elementAt(Object[] a, int index) { return (E) a[index];} 总结:​ 从以上的增删改查中我们可以发现，增删改都需要获得锁，并且锁只有一把，而读操作不需要获得锁，支持并发。为什么增删改中都需要创建一个新的数组，操作完成之后再赋给原来的引用？这是为了保证get的时候都能获取到元素，如果在增删改过程直接修改原来的数组，可能会造成执行读操作获取不到数据。","link":"/myblob/2020/01/30/ArrayList/"},{"title":"ConcurrentHashMap","text":"ConcurrentHashMap 实现原理分析concurrent容器是建立在CAS(Compare and Swap)乐观锁机制上的一种线程安全的容器， CAS机制这里只做简单表述: ​ CAS有三个操作数：内存值V、旧的预期值A、要修改的值B，当且仅当预期值A和内存值V相同时，将内存值修改为B并返回true，否则什么都不做并返回false。 note： 有 操作系统 学习基础的同学会很好理解concurrent相关的内容 一.unsafe类java中的CAS机制需要采用Unsafe类实现。众所周知 java 是一门解释型语言，运行在jvm虚拟机环境下,与具体的物理机平台无关。在java中， 除基本类型 ，所有的类型通过new 关键字分配内存，在对象的生命周期内程序员不需要关心内存的溢出问题 ，内存的回收通过gc来完成，那么作为java程序员就不需要关注在物理机器上的内存分配了吗? 答案显然是否定的，例如在netty中，会使用堆外内存，这些内存不从属于jvm规范中的堆内存，是直接申请的。jdk中提供了 unsafe类来完成一些与物理硬件相关的操作。 通常unsafe类是不提供给普通开发者使用的，在实现中unsafe类设计为单例模式，需要使用 引导类加载器（bootstrap class loader）进行加载。 1234567891011private Unsafe() {}public static Unsafe getUnsafe() { Class var0 = Reflection.getCallerClass(2); if (var0.getClassLoader() != null) { throw new SecurityException(\"Unsafe\"); } else { return theUnsafe; }} getUnsafe() 被设计成只能从引导类加载器（bootstrap class loader）加载。 解决这个问题可以采取两个方法： 1）可以令代码 “ 受信任 “。运行程序时，通过 JVM 参数设置 bootclasspath 选项，指定系统类路径加上使用的一个 Unsafe 路径。 1java -Xbootclasspath:/usr/jdk1.7.0/jre/lib/rt.jar:. com.mishadoff.magic.UnsafeClient 2）通过 Java 反射机制。 123Field f = Unsafe.class.getDeclaredField(\"theUnsafe\");f.setAccessible(true);Unsafe unsafe = (Unsafe) f.get(null); 在 IDE 中，这些方法会被标志为 Error，可以通过以下设置解决： Preferences -&gt; Java -&gt; Compiler -&gt; Errors/Warnings -&gt; Deprecated and restricted API -&gt; Forbidden reference -&gt; Warning 在unsafe中 很多的方法由底层的本地方法实现。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384/** Implementation for put and putIfAbsent */ final V putVal(K key, V value, boolean onlyIfAbsent) { if (key == null || value == null) throw new NullPointerException(); int hash = spread(key.hashCode()); int binCount = 0; for (Node&lt;K,V&gt;[] tab = table;;) { Node&lt;K,V&gt; f; int n, i, fh; K fk; V fv; /** * 如果桶没有初始化 则初始化桶,否则 */ if (tab == null || (n = tab.length) == 0) tab = initTable(); else if ((f = tabAt(tab, i = (n - 1) &amp; hash)) == null) { if (casTabAt(tab, i, null, new Node&lt;K,V&gt;(hash, key, value))) break; // no lock when adding to empty bin } else if ((fh = f.hash) == MOVED) //当前正在对tab做扩容操作 本线程加入到扩容操作中 tab = helpTransfer(tab, f); //桶元素第一个节点正好是待操作节点 且 onlyIfAbsent ==true 不允许修改 则直接返回 else if (onlyIfAbsent // check first node without acquiring lock &amp;&amp; fh == hash &amp;&amp; ((fk = f.key) == key || (fk != null &amp;&amp; key.equals(fk))) &amp;&amp; (fv = f.val) != null) return fv; else { /** *在桶的这个位置元素 就需要进行上锁，并且链表的hash&gt;0就进行在尾部添加Node的过程 * */ V oldVal = null; synchronized (f) { if (tabAt(tab, i) == f) { if (fh &gt;= 0) { binCount = 1; for (Node&lt;K,V&gt; e = f;; ++binCount) { K ek; //针对 头结点的优化 //在头结点上则直接进行replace策略 if (e.hash == hash &amp;&amp; ((ek = e.key) == key || (ek != null &amp;&amp; key.equals(ek)))) { oldVal = e.val; if (!onlyIfAbsent) e.val = value; break; } //非头结点 则在链表的最后进行添加 Node&lt;K,V&gt; pred = e; if ((e = e.next) == null) { pred.next = new Node&lt;K,V&gt;(hash, key, value); break; } } } //判断 头结点是否是一颗红黑树做添加操作 else if (f instanceof TreeBin) { Node&lt;K,V&gt; p; binCount = 2; if ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key, value)) != null) { oldVal = p.val; if (!onlyIfAbsent) p.val = value; } } else if (f instanceof ReservationNode) throw new IllegalStateException(\"Recursive update\"); } } //超过链表阈值 转化为红黑树 if (binCount != 0) { if (binCount &gt;= TREEIFY_THRESHOLD) treeifyBin(tab, i); if (oldVal != null) return oldVal; break; } } } //计数 在这里会进行扩容 addCount(1L, binCount); return null; } 处于扩容状态下的时候 多线程辅助进行扩容,如hashMap 中的扩容策略相同， 每次都会将桶数量扩充为原有的两倍,这样，每个entry 新的hash值要么不变，要么是原有 hashValue + oldCapcity，这样就保证了多线程条件下参与扩容线程之间互不干扰，同时为了降低任务量太少导致频繁的线程切换，还规定了根据cpu数量计算线程一次tansfer的任务量。 12345678910111213141516171819202122final Node&lt;K,V&gt;[] helpTransfer(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt; f) { Node&lt;K,V&gt;[] nextTab; int sc; if (tab != null &amp;&amp; (f instanceof ForwardingNode) &amp;&amp; (nextTab = ((ForwardingNode&lt;K,V&gt;)f).nextTable) != null) { //计算sizeCtl 前16位 标记 int rs = resizeStamp(tab.length) &lt;&lt; RESIZE_STAMP_SHIFT; while (nextTab == nextTable &amp;&amp; table == tab &amp;&amp; (sc = sizeCtl) &lt; 0) { //已经是扩容线程的最大值 不需要参加扩容 if (sc == rs + MAX_RESIZERS || sc == rs + 1 || transferIndex &lt;= 0) break; //可以参加扩容 将扩容线程数量+1 if (U.compareAndSetInt(this, SIZECTL, sc, sc + 1)) { transfer(tab, nextTab); break; } } return nextTab; } return table; } transfer： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140 private static final int MIN_TRANSFER_STRIDE = 16;private final void transfer(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt;[] nextTab) { int n = tab.length, stride; //计算每个线程需迁移的hash桶的数量 //ncpu为物理机cpu的数量 // 对于多核机器，每个线程处理的数量&gt;=16 if ((stride = (NCPU &gt; 1) ? (n &gt;&gt;&gt; 3) / NCPU : n) &lt; MIN_TRANSFER_STRIDE) stride = MIN_TRANSFER_STRIDE; // subdivide range if (nextTab == null) { // initiating try { @SuppressWarnings(\"unchecked\") Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])new Node&lt;?,?&gt;[n &lt;&lt; 1]; nextTab = nt; } catch (Throwable ex) { // try to cope with OOME sizeCtl = Integer.MAX_VALUE; return; } nextTable = nextTab; transferIndex = n; } //在旧的桶中设置转发节点 int nextn = nextTab.length; ForwardingNode&lt;K,V&gt; fwd = new ForwardingNode&lt;K,V&gt;(nextTab); boolean advance = true; boolean finishing = false; // to ensure sweep before committing nextTab for (int i = 0, bound = 0;;) { Node&lt;K,V&gt; f; int fh; while (advance) { int nextIndex, nextBound; if (--i &gt;= bound || finishing) advance = false; else if ((nextIndex = transferIndex) &lt;= 0) { i = -1; advance = false; } else if (U.compareAndSetInt (this, TRANSFERINDEX, nextIndex, nextBound = (nextIndex &gt; stride ? nextIndex - stride : 0))) { bound = nextBound; i = nextIndex - 1; advance = false; } } if (i &lt; 0 || i &gt;= n || i + n &gt;= nextn) { int sc; if (finishing) { nextTable = null; table = nextTab; sizeCtl = (n &lt;&lt; 1) - (n &gt;&gt;&gt; 1); return; } if (U.compareAndSetInt(this, SIZECTL, sc = sizeCtl, sc - 1)) { if ((sc - 2) != resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT) return; finishing = advance = true; i = n; // recheck before commit } } else if ((f = tabAt(tab, i)) == null) advance = casTabAt(tab, i, null, fwd); else if ((fh = f.hash) == MOVED) advance = true; // already processed else { synchronized (f) { if (tabAt(tab, i) == f) { Node&lt;K,V&gt; ln, hn; if (fh &gt;= 0) { int runBit = fh &amp; n; Node&lt;K,V&gt; lastRun = f; for (Node&lt;K,V&gt; p = f.next; p != null; p = p.next) { int b = p.hash &amp; n; if (b != runBit) { runBit = b; lastRun = p; } } if (runBit == 0) { ln = lastRun; hn = null; } else { hn = lastRun; ln = null; } for (Node&lt;K,V&gt; p = f; p != lastRun; p = p.next) { int ph = p.hash; K pk = p.key; V pv = p.val; if ((ph &amp; n) == 0) ln = new Node&lt;K,V&gt;(ph, pk, pv, ln); else hn = new Node&lt;K,V&gt;(ph, pk, pv, hn); } setTabAt(nextTab, i, ln); setTabAt(nextTab, i + n, hn); setTabAt(tab, i, fwd); advance = true; } else if (f instanceof TreeBin) { TreeBin&lt;K,V&gt; t = (TreeBin&lt;K,V&gt;)f; TreeNode&lt;K,V&gt; lo = null, loTail = null; TreeNode&lt;K,V&gt; hi = null, hiTail = null; int lc = 0, hc = 0; for (Node&lt;K,V&gt; e = t.first; e != null; e = e.next) { int h = e.hash; TreeNode&lt;K,V&gt; p = new TreeNode&lt;K,V&gt; (h, e.key, e.val, null, null); if ((h &amp; n) == 0) { if ((p.prev = loTail) == null) lo = p; else loTail.next = p; loTail = p; ++lc; } else { if ((p.prev = hiTail) == null) hi = p; else hiTail.next = p; hiTail = p; ++hc; } } ln = (lc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(lo) : (hc != 0) ? new TreeBin&lt;K,V&gt;(lo) : t; hn = (hc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(hi) : (lc != 0) ? new TreeBin&lt;K,V&gt;(hi) : t; setTabAt(nextTab, i, ln); setTabAt(nextTab, i + n, hn); setTabAt(tab, i, fwd); advance = true; } else if (f instanceof ReservationNode) throw new IllegalStateException(\"Recursive update\"); } } } } }","link":"/myblob/2020/02/20/ConcurrentHashMap/"},{"title":"HashMap","text":"HashMap 实现原理分析一.存储结构​ HashMap使用数组加entity链表的方式进行存储数据 ​ hash函数通过对象hashcode 算出 而对象的hashcode方法则依赖于native实现，hashcode可以理解为与对象存储地址相关。 本质上 算出hash值之后，只需要令hash值与数组长度取余 即可知道对象在数组中的index索引，而hashmap采用链表方式来解决hash碰撞问题，故在数组index位置上，会将待插入的对象放置在链表末尾(1.8之后) hash中的基本node结构 1234567 每一对key - value结构存储的mode数据结构static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; { final int hash; final K key; V value; Node&lt;K,V&gt; next;} hash值计算函数,对于null值 会被直接映射到0位置上 1234static final int hash(Object key) { int h; return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);} hashmap 中包含了 key value entry 三个的容器和迭代器所以在hashmap中 可以对key value 进行迭代，也可以使用entry的迭代器对每一对 k-v 进行遍历操作 ，并且 在三者（key value entry）的容器中 还实现了Spliterator 接口 支持通过写action类对容器中的值进行操作 二.Map 接口说明interface:map是abstract:Dictionary的替代，map不能包含重复的key且每个key最多只能映射到一个value。map接口中包含了三个集合类collection的视图collection-view,分别是key的set集合，value的set集合以及key-value maping的set集合，在任何map的实现类中，三种集合中元素顺序order通常与各自集合迭代器的顺讯相同，但是在treeMap(采用红黑树实现)中有特殊规定。 note:对于可变类型作为key值需要特别注意，因为key值运算得到hashNumber 的过程中与key对象的内存地址以及内容有关系，而value则无所谓，而且map类自身也不要使用作为key值，尽管这样做在程序上是可行的。 所有的通用map都需要实现两个“标准的”构造器： 12map();//无参构造map(map col);//参数为map的构造器 Map接口中包含了一个数据结构Entry的interface定义，如下所示: 三.核心方法扩容阈值调整: 12345678910111213141516static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30;/**这个方法是返回&gt;=cap的最小的2的整数次幂* -1 用补码表示为 0xffff_ffff*Integer.numberOfLeadingZeros() 方法返回给定的int整数cap-1高位0的个数*example :* cap = 20 =&gt;cap -1 = 19 = 0x10011 即19(10) 对于32位整数 高位有27个0* 0xffff_ffff &gt;&gt;&gt; 27 = 11111B (逻辑右移27位，高位补0)* return 11111B + 1 = 100000B = 2^5 = 32*/static final int tableSizeFor(int cap) { int n = -1 &gt;&gt;&gt; Integer.numberOfLeadingZeros(cap - 1); return (n &lt; 0) ? 1 : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;} hashmap的扩容函数 resize 分析: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120final Node&lt;K,V&gt;[] resize() { Node&lt;K,V&gt;[] oldTab = table; int oldCap = (oldTab == null) ? 0 : oldTab.length; int oldThr = threshold; int newCap, newThr = 0; //首先计算扩容后 容量 和 阈值 if (oldCap &gt; 0) { //oldCap大于等于最大值 只将扩容阈值增加到最大 if (oldCap &gt;= MAXIMUM_CAPACITY) { threshold = Integer.MAX_VALUE; return oldTab; } //oldCap 不大于 最大值下 将 capcity 值和 threshold 阈值 扩容到两倍 else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp; oldCap &gt;= DEFAULT_INITIAL_CAPACITY) newThr = oldThr &lt;&lt; 1; // double threshold } //当 capcity&lt;0 扩容阈值threshold&gt;0 新capcity = threshold else if (oldThr &gt; 0) newCap = oldThr; else { //capcity&lt;0 threshold&lt;0 默认初始化操作 newCap = DEFAULT_INITIAL_CAPACITY; newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY); } //经过上面的步骤 当阈值 == 0 需要对阈值进行调整 if (newThr == 0) { //当 capcity &lt;max时 阈值为 默认的 capcity * 负载因子(默认0.75) float ft = (float)newCap * loadFactor; newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ? (int)ft : Integer.MAX_VALUE); } threshold = newThr; /* *接下来对原有Node[] table 进行扩容 *每个数组元素table[index]中 对指向的链与红黑树分别处理 */ @SuppressWarnings({\"rawtypes\",\"unchecked\"}) Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap]; table = newTab; if (oldTab != null) { for (int j = 0; j &lt; oldCap; ++j) { Node&lt;K,V&gt; e; if ((e = oldTab[j]) != null) { oldTab[j] = null; if (e.next == null) //对于 单个 Node 直接计算元素位置 newTab[e.hash &amp; (newCap - 1)] = e; //对红黑树做处理 else if (e instanceof TreeNode) ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap); else { // preserve order //链表形式的Node 元素 Node&lt;K,V&gt; loHead = null, loTail = null; Node&lt;K,V&gt; hiHead = null, hiTail = null; Node&lt;K,V&gt; next; do { next = e.next; /** * A % B操作的原理为模运算，是计算 X = (A - n*B) &lt; B 的最小正整数X * hashMap中要计算 hash(key) % capcity * 而这里有一个非常特殊的规定，即 capcity 为 2^n * 在取余操作中 当 B 为2^n 时 * 则可以通过表达式 X &amp; (2^n - 1) 操作来简化取余过程 * 以下是此种情形下 A % B 的说明:(借用汇编对二进制的表示方法) * AH(A比B的高位) 不会对结果产生影响,而产生结果影响的实际上是 AL(低位) * 我们将A的二进制分为三块: * A = AH-M(0 or 1)-AL,则 B = BH(全0) -1- BL(全0) * 可以得出 AL表示的整数值即为 A%B 的结果 * 而只有 M 这一位对 A &amp; B 产生了影响 而这一位&amp;运算的结果反映了: * 是否存在 B &lt;= (X = A - n*B) &lt; B*2, 即是否有 A % (B*2) &gt;= B * 在这种情况下(A&amp;B != 0)需要对原来的hash结果,加上一个 oldCap的偏移量 * 这里给出一个实际的example: * capcity = 16 objA.hashValue = 5 objB.hashValue = 21 * 扩容前： * 15 = 0000 1111 &amp; * 5 = 0000 0101 ---&gt; 0000 0101 = 5 * 21 = 0001 0101 ---&gt; 0000 0101 = 5 * 扩容后： * 31 = 0001 1111 &amp; * 5 = 0000 0101 ---&gt; 0000 0101 = 5 * 21 = 0001 0101 ---&gt; 0001 0101 = 21 */ if ((e.hash &amp; oldCap) == 0) { if (loTail == null) //这里是用来确定链表中的首元素 只在第一次运行时会进入 loHead = e; else //成链操作 loTail.next = e; //链表的操作元素 每次遍历都会在loTail指向的元素进行添加 loTail = e; } //需要改变元素在数组中位置 else { if (hiTail == null) //保存首地址 hiHead = e; else //成链操作 hiTail.next = e; hiTail = e; } } while ((e = next) != null); //将链首元素放到对应的数组index中 if (loTail != null) { loTail.next = null; newTab[j] = loHead; } if (hiTail != null) { hiTail.next = null; newTab[j + oldCap] = hiHead; } } } } } return newTab; } putVal 方法 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) { Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i; if ((tab = table) == null || (n = tab.length) == 0) n = (tab = resize()).length; //这里是通过当前哈希值与桶长度做取余运算 然后判断是否为链表头结点 if ((p = tab[i = (n - 1) &amp; hash]) == null) tab[i] = newNode(hash, key, value, null); else { Node&lt;K,V&gt; e; K k; /**这里分为三种情况 * 1 要插入的值正好是链表头结点（相当于变成replace） * 2 要插入的值不在头结点，且结点采用红黑树 * 3 要插入的值不在头结点，且结点采用链表 */ if (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) //情况一 直接修改值 e = p; else if (p instanceof TreeNode) e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value); else { //链表的情况 //从链表头查询到链表尾部 如果有就replace 没有就新增 for (int binCount = 0; ; ++binCount) { if ((e = p.next) == null) { p.next = newNode(hash, key, value, null); //链表转化为红黑树的判定 if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st treeifyBin(tab, hash); break; } if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) break; p = e; } } if (e != null) { // existing mapping for key V oldValue = e.value; if (!onlyIfAbsent || oldValue == null) e.value = value; afterNodeAccess(e); return oldValue; } } ++modCount; if (++size &gt; threshold) resize(); afterNodeInsertion(evict); return null; }","link":"/myblob/2020/02/20/HashMap/"},{"title":"Unsigned","text":"java中unsigned类型的表示方式在java网络编程中经常使用到无符号类型，而在java中并没有无符号类型，基本类型中的数值类型都是带有符号的。所以在java 中为了表示一个无符号类型，最长使用的做法就是将长度短的数值 放在 更长的数值类型中保存（如将unsigned short 放入 int中）。在实际运用中 我们可以用 byte[]作为一个间接的容器来保存无符号数,当需要计算时在通过类型提升，转换为空间要求最低的类型来进行计算。 而关于如何做类型与byte[]做转换 ，首先要知道java 基本类型的长度大小: 基本类型 大小 最小值 最大值 int 32bit -2^31 +2^32-1 short 16bit -2^15 +2^15-1 byte 8bit -128 +127 long 64bit -2^63 +2^63-1 float 32bit IEEE754 IEEE754 double 64bit IEEE754 IEEE754 char 16bit Unicode 0 Unicode 2^16-1 boolean 1bit —- —- 其次需要了解基本的位运算符和java 中的算术移位和逻辑移位运算,这里不做展开说明. 最后要决定byte数组中元素的存储形式:采用大端还是小端模式进行存储 下面来看一个 在 *大端模式 *下long 类型转换为 unsigned int ： 123456789101112//long 转unsigned intpublic static byte[] longToInt(int m){ //long中存储了一个无符号整形size_t byte[] result = new byte[4];//byte数组大小为int的长度 4字节 //大端模式下 数据高位字节存储在byte[]中的低位 //每8位数据进行一次数组append result[0] = (byte) (m&gt;&gt;&gt;24&amp;0xff); result[1] = (byte) (m&gt;&gt;&gt;16&amp;0xff); result[2] = (byte) (m&gt;&gt;&gt;8&amp;0xff); result[3] = (byte) (m&amp;0xff); return result;} 对大端模式下的byte数组数据转换为long进行计算，这里对byte数组低位数据(对应在数据的高位字节 )在数组长度超过8位时,进行舍弃: 12345678910111213141516// unsigned_short --&gt; long 高位补0 //采用长定点数存取短定点数 过长则保留低位 public static long longValueOf(byte[] b){ long result = 0L; int end = b.length-1; int pos = -1; //位数超过 取低位数据 if(b.length&gt;8) pos = b.length-9; for(int i = end;i&gt;pos;i--){ //从低位字节开始进行遍历 每次移动 都需要偏移到对应位数上 result+= (b[i] &amp; 0xff)&lt;&lt;((end-i)*8); } return result; } 这样就完成了 在long中存取一个unsigned int数据 ，而在存储时可以通过byte数组存储;下面是对所有unsigned short 和 unsigned byte操作的代码: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879//short 转unsigned bytepublic static byte[] shortToByte(short m){ byte[] result = new byte[1]; //result[0] = (byte) (m&gt;&gt;&gt;8&amp;0xff); result[0] = (byte) (m&amp;0xff); return result;}// int 转 unsigned shortpublic static byte[] intToShort(int m){ byte[] result = new byte[2]; result[0] = (byte) (m&gt;&gt;&gt;8&amp;0xff); result[1] = (byte) (m&amp;0xff); return result;}//long 转unsigned intpublic static byte[] longToInt(int m){ byte[] result = new byte[4]; result[0] = (byte) (m&gt;&gt;&gt;24&amp;0xff); result[1] = (byte) (m&gt;&gt;&gt;16&amp;0xff); result[2] = (byte) (m&gt;&gt;&gt;8&amp;0xff); result[3] = (byte) (m&amp;0xff); return result;}// unsigned_short --&gt; long 高位补0//采用长定点数存取短定点数 过长则保留低位public static long longValueOf(byte[] b){ long result = 0L; int end = b.length-1; int pos = -1; //位数超过 取低位数据 if(b.length&gt;8) pos = b.length-9; for(int i = end;i&gt;pos;i--){ //从低位字节开始进行遍历 每次移动 都需要偏移到对应位数上 result+= (b[i] &amp; 0xff)&lt;&lt;((end-i)*8); } return result;}// unsigned_short --&gt; long 高位补0//采用长定点数存取短定点数 过长则保留低位public static int intValueOf(byte[] b){ int result = 0; int end = b.length-1; int pos = -1; //位数超过 取低位数据 if(b.length&gt;4) pos = b.length-5; for(int i = end;i&gt;pos;i--){ //从低位字节开始进行遍历 每次移动 都需要偏移到对应位数上 result+= (b[i] &amp; 0xff)&lt;&lt;((end-i)*8); } return result;}// unsigned_short --&gt; long 高位补0//采用长定点数存取短定点数 过长则保留低位public static short shortValueOf(byte[] b){ short result = 0; int end = b.length-1; int pos = -1; //位数超过 取低位数据 if(b.length&gt;2) pos = b.length-3; for(int i = end;i&gt;pos;i--){ //从低位字节开始进行遍历 每次移动 都需要偏移到对应位数上 result+= (b[i] &amp; 0xff)&lt;&lt;((end-i)*8); } return result;}","link":"/myblob/2020/02/20/Unsigned/"},{"title":"Reflect","text":"reflect 与 proxy要想理解反射的原理，首先要了解什么是类型信息。Java让我们在运行时识别对象和类的信息，主要有2种方式：一种是传统的RTTI，它假定我们在编译时已经知道了所有的类型信息；另一种是反射机制，它允许我们在运行时发现和使用类的信息。 jvm内存分布 jvm 加载流程 创建对象 一、Class对象​ .class 文件被加载到内存之后，jvm中会创建 java.lang.Class 类型的对象，这也就是java中万物皆对象的由来，每一个Class对象都代表着一个 .class 文件的代码信息，Class对象仅在需要的时候才会加载。而静态代码在类加载器加载的时候就会执行。 ​ 我们来看一段jdbc的example： 12Class.forName(\"com.mysql.jdbc.Driver\");Connection conn=DriverManager.getConnection(url,user,password); ​ 这里的Class.forName(string str) 方法就是进行数据库驱动类的加载。这里在加载类会调用静态带码块中的内容进行驱动的注册。如果没有这行代码会怎么样呢？会提示没有注册驱动，而导致无法运行 ​ Class.forName（）方法在执行的过程中，类加载器会检查 需要加载的类是否已经被加载过，如果没有加载，默认的类加载器就会根据类名进行加载。 同样为获取类的Class对象，以下两种方式获取的是不同的。 12Class c1 = Class.forName(&quot;com.nonoy.Test&quot;);Class c2 = Test.Class; Test.Class ，不会加载类中的静态代码,也就是静态代码不会被执行。类的加载一般有三个步骤： 加载：由类加载器完成，找到对应的字节码，创建一个Class对象 链接：验证类中的字节码，为静态域分配空间 初始化：如果该类有超类，则对其初始化，执行静态初始化器和静态初始化块 Note: 当需要进行向下转型时，编译器会通过类型检查判断是否合法，在向下转型前可以通过关键字instanceof 判断** 二、反射基础​ java中的反射位于 java.lang.reflect 包中，提供了对于类的的 方法 （method），超类（superClass）， 接口（interface），属性（field）等进行的相关操作，当时用反射时，我们可以在跳过new关键字的范畴，动态的创建对象，简化类之间的依赖关系，提供高灵活性的程序。 ​ 反射是在程序运行时打开 和检查.class 文件的。当通过反射操作一个未知对象时，JVM会检查这个对象，确定它是属于哪个类的。对于那个类而言，必须是可以获取的，但是这个类并不一定需要在本进程中，因为通过动态代理+网络编程，可以实现在另一个进程中获取到类的运行实例，并通过网络将结果传送回来,而这也是RPC框架的基础。","link":"/myblob/2020/02/20/Reflect/"}],"tags":[],"categories":[]}